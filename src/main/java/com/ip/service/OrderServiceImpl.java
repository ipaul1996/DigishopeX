package com.ip.service;

import java.text.DecimalFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import com.ip.dto.CancelledDTO;
import com.ip.dto.DaywiseSalesData;
import com.ip.dto.OrderDTO;
import com.ip.dto.ProductDTOV3;
import com.ip.dto.ProductDTOV4;
import com.ip.dto.ProductDTOV5;
import com.ip.dto.ReturnRequestDTO;
import com.ip.dto.RevenueDTO;
import com.ip.dto.SalesAnalysisDTO;
import com.ip.enums.OrderStatus;
import com.ip.exception.CredentialException;
import com.ip.exception.CustomerException;
import com.ip.exception.OrderException;
import com.ip.exception.ProductException;
import com.ip.exception.SalesAnalysisNotFoundException;
import com.ip.exception.ShipperException;
import com.ip.exception.SupplierException;
import com.ip.model.CancelledOrders;
import com.ip.model.Cart;
import com.ip.model.Customer;
import com.ip.model.OrderDetail;
import com.ip.model.Orders;
import com.ip.model.Payment;
import com.ip.model.Product;
import com.ip.model.ReturnRequestedOrders;
import com.ip.model.ReturnedOrderDetails;
import com.ip.model.Shipper;
import com.ip.model.Supplier;
import com.ip.repository.AdminRepo;
import com.ip.repository.CancelledOrderRepo;
import com.ip.repository.CartProductQuantityRepo;
import com.ip.repository.CategoryRepo;
import com.ip.repository.CustomerRepo;
import com.ip.repository.OrderDetailRepo;
import com.ip.repository.OrdersRepo;
import com.ip.repository.ProductRepo;
import com.ip.repository.ReturnRequestedOrdersRepo;
import com.ip.repository.SalesDataRepo;
import com.ip.repository.ShipperRepo;
import com.ip.repository.SupplierRepo;

@Service
public class OrderServiceImpl implements OrderService {
	
	
	@Autowired
	private CustomerRepo cRepo;
	
	@Autowired
	private CartService cService;
	
	@Autowired
	private OrdersRepo oRepo;
	
	@Autowired
	private CartProductQuantityRepo cpqRepo;
	
	@Autowired
	private AdminRepo aRepo;
	
	@Autowired
	private OrderDetailRepo odRepo;
	
	@Autowired
	private SupplierRepo suppRepo;
	
	
	@Autowired
	private ShipperRepo shipRepo;
	
	@Autowired
	private ProductRepo pRepo;
	
	
	@Autowired
	private ReturnRequestedOrdersRepo rroRepo;
	
	@Autowired
	private CancelledOrderRepo canRepo;
	
	
	@Autowired
	private CategoryRepo catRepo;
	
	@Autowired
	private SalesDataRepo sdRepo;
	
	
	
	public String formatString(String string) {
		
		if(string.isBlank() || string.isBlank() || string == null) {
			return string;
		}
		
		return  Character.toUpperCase(string.charAt(0)) + string.substring(1).toLowerCase();		
	}
	
	
	@Override
	public Supplier registerSupplier(Supplier supplier) throws SupplierException {
		
		if(supplier.getSupplierID() != null) {
			throw new SupplierException("You don't need to provide SupplierID, as it is autogenerated");
		}
		
		if(catRepo.findByCategoryName(formatString(supplier.getCategoryName())) == null) {
			throw new SupplierException("Invalid category name");
		}
		
		supplier.setCategoryName(formatString(supplier.getCategoryName()));
		
		return suppRepo.save(supplier);
	}
	
	@Override
	public String changeActiveStatusOfSupplier(Integer supplierID) throws SupplierException {
		
		Optional<Supplier> op = suppRepo.findById(supplierID);
		
		if(op.isEmpty()) {
			throw new SupplierException("Invalid supplierID");
		}
		
		Supplier supplier = op.get();
		
		supplier.setActive(!supplier.getActive());
		
		suppRepo.save(supplier);
		
		return "Active status for the supplier with ID : " + supplier.getSupplierID() + 
				" has changed to " + supplier.getActive();
		
	}
	
	@Override
	public Shipper registerShipper(Shipper shipper) throws ShipperException {
		
		if(shipper.getShipperID() != null) {
			throw new ShipperException("You don't need to provide ShipperID, as it is autogenerated");
		}
		
		return shipRepo.save(shipper);
	}
	
	
	@Override
	public String changeActiveStatusOfShipper(Integer shipperID) throws ShipperException {
		
		Optional<Shipper> op = shipRepo.findById(shipperID);
		
		if(op.isEmpty()) {
			throw new ShipperException("Invalid supplierID");
		}
		
		Shipper shipper = op.get();
		
		shipper.setActive(!shipper.getActive());
		
		shipRepo.save(shipper);
		
		return "Active status for the shipper with ID : " + shipper.getShipperID() + 
				" has changed to " + shipper.getActive();
		
	}
	
	
	@Override
	public OrderDTO makePurchase(Payment payment) throws SupplierException, ProductException, CustomerException, CredentialException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		Customer customer = cRepo.findByEmail(auth.getName()).get();
		
		Cart cart = customer.getCart();
		
		if(cart == null || cart.getProducts().size() == 0) {
			throw new ProductException("Cart has no product i.e., empty. Please add products to make purchase");
		}
		
		final Orders o = new Orders();
		
		List<Product> products = cart.getProducts();
		
		Set<String> supplierList = new LinkedHashSet<>();
		        	
	    for(Product p : products) {
			
			OrderDetail od = new OrderDetail();
			
			od.setProduct(p);
			
			od.setQuantity(cpqRepo.findByCartIdAndProductId(cart.getCartId(), customer.getUserid()).getProductQuantity());
			cpqRepo.delete(cpqRepo.findByCartIdAndProductId(cart.getCartId(), customer.getUserid()));
			
			
			//Assign Supplier
			//Find all the suppliers
			List<Supplier> suppliers =  suppRepo.findAll();
			
			if(suppliers.isEmpty()) {
				throw new SupplierException("No supplier found...");
			}
			
			//Filter out the suppliers who are active and supplies the products of same category as the product belongs to
			suppliers = suppliers.stream()
						         .filter(e -> e.getActive() == true && e.getCategoryName().equalsIgnoreCase(p.getCategory().getCategoryName()))
						         .collect(Collectors.toList());
			
			if(suppliers.isEmpty()) {
				throw new SupplierException("No supplier found...");
			}
			
			//Randomly selecting a supplier from the list of suppliers
			Supplier supplier = suppliers.get(new Random().nextInt(suppliers.size()));
			
			supplierList.add(supplier.getCompanyName());
			
			
			//Associate supplier and orderdetails with each other
			od.setSupplier(supplier);
			supplier.getDetails().add(od);
			
			//Associate order and orderdetails with each other
			od.setOrder(o);
			o.getDetails().add(od);
			
		}
		
	    //Clearing the cart
		products.clear();
		cart.setProducts(products);
		
		//Associating the payment and orders with each other 
		o.setPayment(payment);
		payment.setOrder(o);
		
		//Setting the total_order_amount 
		o.setTotal_order_amount(cService.showCart(customer.getEmail()).getSubtotal());
		
		//Setting order status
		o.setOrderStatus(OrderStatus.PENDING);
		
		//Retrieving all available shippers
		List<Shipper> shippers =  shipRepo.findAll();
		
		//Filter out shippers who are active
		shippers = shippers.stream()
						   .filter(e -> e.getActive() == true)
						   .collect(Collectors.toList());
		
		//Randomly selecting a shipper from the list of shippers
		Shipper shipper = shippers.get(new Random().nextInt(shippers.size()));
		
		//Associating shipper and orders with each other
		o.setShipper(shipper);
		shipper.getOrders().add(o);
		
		//Assigning dynamically generated shipDateTime
		LocalDateTime shipDateTime =  o.getOrderDateTime().toLocalDate()
									                      .plusDays(1)
									                      .atTime(LocalTime.of(new Random().nextInt(10, 21), 
									                    		  new Random().nextInt(60), new Random().nextInt(60)));
		o.setShipDateTime(shipDateTime);
		
		//Assigning dynamically generated deliveryDateTime
		LocalDateTime deliveryDateTime =  o.getOrderDateTime().toLocalDate()
                											  .plusDays(5)
                											  .atTime(LocalTime.of(new Random().nextInt(10, 21), 
                													  new Random().nextInt(60), new Random().nextInt(60)));
		o.setDeliveryDateTime(deliveryDateTime);
	
		//Persist the order object
		Orders o1 = oRepo.save(o);
		
		//Create OrderDTO which contains all the required informations of the saved order
		OrderDTO od = new OrderDTO();
		
		od.setCustomerID(customer.getUserid());
		od.setOrderID(o1.getOrderID());
		od.setOrderDateTime(o1.getOrderDateTime());
		od.setShipDateTime(shipDateTime);
		od.setDeliveryDateTime(deliveryDateTime);
		od.setShipper(shipper.getCompanyName());
		od.setSuppliers(String.join(",", supplierList));
		od.setDetails(o1.getDetails());
		od.setTotal_order_amount(o1.getTotal_order_amount());

		return od;
		
	}

	
	@Override
	public CancelledDTO cancelOrder(Integer orderID) throws OrderException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		Customer customer = cRepo.findByEmail(auth.getName()).get();
		
		if(customer.getOrders() == null || customer.getOrders().isEmpty()) {
			throw new OrderException("No order is made by the customer");
		}
		
		Orders od = customer.getOrders().stream()
										.filter(o -> o.getOrderID() == orderID)
										.collect(Collectors.toList())
										.get(0);
		
		if(od == null) {
			throw new OrderException("Invalid orderId");
		}
		
		if(od.getOrderStatus().equals(OrderStatus.CANCELLED_AND_REFUND_IN_PROGESS) ||
				od.getOrderStatus().equals(OrderStatus.RETURN_IN_PROGRESS) || 
				od.getOrderStatus().equals(OrderStatus.RETURNED_AND_REFUND_IN_PROGESS) || 
				od.getOrderStatus().equals(OrderStatus.REFUNDED) ) {
			throw new OrderException("Invalid action...");
		}
		
		
		if(!LocalDateTime.now().isBefore(od.getDeliveryDateTime())) {
			throw new OrderException("Products are already being delivered so you can't cancel the order now, if not satisfied please return");
		}
		
		if(!LocalDateTime.now().isBefore(od.getShipDateTime())) {
			throw new OrderException("Products are already being shipped so you can't cancel the order now, if not satisfied please return after receiving it");
		}
		
		od.setCancelled(true);
		
		od.getDetails().stream()
					   .forEach(d -> {
						  Product pr = pRepo.findById(d.getProduct().getProductId()).get();					  
						  pr.setStockQuantity(pr.getStockQuantity() + d.getQuantity());
						  pRepo.save(pr);
					   });
		
		CancelledOrders cOrders = new CancelledOrders();
		
		cOrders.setOrderID(orderID);
		cOrders.setCancelledON(LocalDateTime.now());
		
		LocalDateTime refundDateTime = cOrders.getCancelledON().toLocalDate()
				  												.plusDays(7)
				  												.atTime(LocalTime.of(new Random().nextInt(10, 21), 
				  														new Random().nextInt(60), new Random().nextInt(60)));
		
		cOrders.setRefundON(refundDateTime);
		
		
		od.setOrderStatus(OrderStatus.CANCELLED_AND_REFUND_IN_PROGESS);
		
		canRepo.save(cOrders);
		oRepo.save(od);
		
		
		CancelledDTO dto = new CancelledDTO();
		
		dto.setOrderID(orderID);
		dto.setCancelledON(cOrders.getCancelledON());
		dto.setCancelledON(cOrders.getRefundON());
		dto.setStatus(OrderStatus.CANCELLED_AND_REFUND_IN_PROGESS);
		
		
		return dto;
		
	}
	
	
	@Override
	@Scheduled(fixedRate = 300000)
	public void updateOrderStatus() {
		
		List<Orders> orders = oRepo.findAll();
		
		if(!orders.isEmpty()) {
			
			for(Orders od : orders) {
				
				LocalDateTime shipDateTime = od.getShipDateTime();				
				LocalDateTime deliveryDateTime = od.getDeliveryDateTime();
				
				if(od.getCancelled()) {
					
					CancelledOrders cOrder = canRepo.findById(od.getOrderID()).get();
					
					if(!LocalDateTime.now().isBefore(cOrder.getRefundON())) {
						od.setOrderStatus(OrderStatus.REFUNDED);
					}
					
					
				} else if(od.getReturnRequested()) {
					
					ReturnRequestedOrders rOrder = rroRepo.findById(od.getOrderID()).get();
					
					if(!LocalDateTime.now().isBefore(rOrder.getFulfillON()) && 
							LocalDateTime.now().isBefore(rOrder.getRefundON())) {
						od.setOrderStatus(OrderStatus.RETURNED_AND_REFUND_IN_PROGESS);
						
					} else if(!LocalDateTime.now().isBefore(rOrder.getRefundON())) {
						od.setOrderStatus(OrderStatus.REFUNDED);
					}
					
				} else if(!LocalDateTime.now().isBefore(deliveryDateTime)) {
					od.setOrderStatus(OrderStatus.DELIVERED);
					
				} else if(!LocalDateTime.now().isBefore(shipDateTime) && LocalDateTime.now().isBefore(deliveryDateTime)) {
					od.setOrderStatus(OrderStatus.SHIPPED);
				}
				
				
				oRepo.save(od);
				
			}
			
		}
		
		

	}

	
	@Override
	public String checkOrderStatus(Integer orderID) throws OrderException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		String role = new ArrayList<>(auth.getAuthorities()).get(0).toString();
		
		Orders od;
		
		if(role.equals("ROLE_CUSTOMER")) {
			
			Customer customer = cRepo.findByEmail(auth.getName()).get();
			
			if(customer.getOrders() == null || customer.getOrders().isEmpty()) {
				throw new OrderException("No order is made by the customer");
			}
			
			 List<Orders> list = customer.getOrders().stream()
									 				 .filter(o -> o.getOrderID().equals(orderID))
									 			     .collect(Collectors.toList());
			
			if(list.isEmpty()) {
				throw new OrderException("Invalid orderID");
			}
			
			od = list.get(0);

		} else {
			
			
			Optional<Orders> op = oRepo.findById(orderID);
			
			if(op.isEmpty()) {
				throw new OrderException("Invalid orderID");
			}
			
			od = op.get();
		}
		
		return od.getOrderStatus().toString();
		
	}
	
	
	@Override
	public ReturnRequestDTO submitReturnRequest(Integer orderID) throws OrderException {
		
		Authentication auth =  SecurityContextHolder.getContext().getAuthentication();
		
		Customer customer = cRepo.findByEmail(auth.getName()).get();
		
		if(customer.getOrders() == null || customer.getOrders().isEmpty()) {
			throw new OrderException("No order is made by the customer");
		}
		
		
		List<Orders> list =  customer.getOrders().stream()
												.filter(e -> e.getOrderID().equals(orderID))
												.collect(Collectors.toList());
		
		if(list.isEmpty()) {
			throw new OrderException("Invalid orderId");
		}
		
		Orders order = list.get(0);
		
		if(order.getOrderStatus().equals(OrderStatus.RETURN_IN_PROGRESS) || 
				order.getOrderStatus().equals(OrderStatus.RETURNED_AND_REFUND_IN_PROGESS) ||
				order.getOrderStatus().equals(OrderStatus.REFUNDED) || 
				order.getOrderStatus().equals(OrderStatus.CANCELLED_AND_REFUND_IN_PROGESS)) {
			throw new OrderException("Invalid action...");
		}
		
		if(order.getDeliveryDateTime().isBefore(LocalDateTime.now())) {
			
			long daysBetween = ChronoUnit.DAYS.between(order.getDeliveryDateTime(), LocalDateTime.now());
			
			if(daysBetween > 7) {
				throw new OrderException("Sorry! You can't return the product as the validity of return request facility is over");
			}
			
			List<OrderDetail> details = order.getDetails();
			
			ReturnRequestedOrders ro = new ReturnRequestedOrders();
			
			ro.setOrderID(order.getOrderID());
			ro.setRequestedON(LocalDateTime.now());
			ro.setFulfillON(LocalDateTime.now().plusDays(3));
			ro.setRefundON(LocalDateTime.now().plusDays(10));
			
			List<ReturnedOrderDetails> details2 = ro.getDetails();
			
			for(OrderDetail od : details) {
				
				ReturnedOrderDetails rod = new ReturnedOrderDetails();
				
				rod.setProductID(od.getProduct().getProductId());
				rod.setQuantity(od.getQuantity());
				
				rod.setOrder(ro);
				details2.add(rod);
				
			}
			
			rroRepo.save(ro);
			
			order.setOrderStatus(OrderStatus.RETURN_IN_PROGRESS);
			order.setReturnRequested(true);
			
			oRepo.save(order);
			
			ReturnRequestDTO dto = new ReturnRequestDTO();
			
			dto.setOrderID(orderID);
			dto.setRequestedON(ro.getRequestedON());
			dto.setFulfillON(ro.getFulfillON());
			dto.setRefundON(ro.getRefundON());
			dto.setStatus(OrderStatus.RETURN_IN_PROGRESS);
			
			return dto;
	
			
		} else {
			throw new OrderException("Product is not delivered yet, so you can't perform this action. "
					+ "Once you receive the product, please make this request again");
		}
		
		
	}
	
	
	@Override
	@Scheduled(fixedRate = 300000)
	public void updateStock() {
		
		List<ReturnRequestedOrders> orders = rroRepo.findAll();
		
	    orders.stream()
	          .forEach(e -> {
	        	  
	        	  if(!e.getFulfillON().isAfter(LocalDateTime.now()) && e.getStockUpdated() == false) {
	        		  
	        		  List<ReturnedOrderDetails> details =  e.getDetails();
	        		  
	        		  details.stream()
	        		  		 .forEach(e1 -> {
	        		  			 
	        		  			  Product pr = pRepo.findById(e1.getProductID()).get();					  
		  						  pr.setStockQuantity(pr.getStockQuantity() + e1.getQuantity());
		  						  pRepo.save(pr);
	        		  			 
	        		  		 });
	        		  
	        	  }
	        	  
	        	  e.setStockUpdated(true);
	        	  
	        	  
	          });
	    
	    
	    rroRepo.saveAll(orders);
	}
	
	
	
	
	@Override
	public List<Orders> getAllOrdersForCustomer() throws CustomerException, OrderException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		Optional<Customer> op = cRepo.findByEmail(auth.getName());
		
		if(op.isEmpty()) {
			throw new CustomerException("No customer details found in the database");
		}
		
		if(op.get().getOrders() == null || op.get().getOrders().isEmpty()) {
			throw new CustomerException("No order is found for the customer");
		}
		
		return op.get().getOrders();
	}


	@Override
	public List<Orders> getAllOrdersForAdmin() throws OrderException {
		
		List<Orders> orders = oRepo.findAll();
		
		if(orders == null || orders.isEmpty()) {
			throw new OrderException("No order found");
		}
		
		return orders;
	}


	@Override
	public Orders getOrderByOrderID(Integer orderID) throws OrderException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		String role = getRole(auth.getAuthorities());
		
		if(role.equals("ROLE_CUSTOMER")) {
			
			Optional<Customer> op = cRepo.findByEmail(auth.getName());
			
			Customer customer = op.get();
			
			List<Orders> orderList =  customer.getOrders().stream()
														  .filter(e -> e.getOrderID().equals(orderID))
														  .collect(Collectors.toList());
			
			if(orderList.isEmpty()) {
				throw new OrderException("Invalid orderID");
			}
			
			return orderList.get(0);
			
		} else {
			return oRepo.findById(orderID).orElseThrow(() -> new OrderException("Invalid orderID"));
		}
		
		
	}


	@Override
	public List<Orders> getAllOrdersByCustomerID(Integer customerID)
			throws OrderException, CustomerException {
		
		Optional<Customer> op =  cRepo.findById(customerID);
		
		if(op.isEmpty()) {
			throw new CustomerException("Invalid customerID");
		}
		
		List<Orders> orders =  op.get().getOrders();
		
		if(orders == null || orders.isEmpty()) {
			throw new OrderException("No order found...");
		}
		
		return orders;
		
	}


	@Override
	public List<Orders> getAllOrdersByCustomerEmail(String email)
			throws CredentialException, OrderException, CustomerException {
		
		Optional<Customer> op =  cRepo.findByEmail(email);
		
		if(op.isEmpty()) {
			throw new CustomerException("Invalid customer email");
		}
		
		List<Orders> orders =  op.get().getOrders();
		
		if(orders == null || orders.isEmpty()) {
			throw new OrderException("No order found...");
		}
		
		return orders;
	}
	
	
	private String getRole(Collection<? extends GrantedAuthority> authorities) {
		
		return new ArrayList<>(authorities).get(0).toString();

	}


//	@Override
//	@Scheduled(fixedRate = 3600000)
//	public void doTodaySalesAnalysis(){
//		
//		List<Orders> allOrders = oRepo.findAll();
//		
//		if(allOrders == null || allOrders.isEmpty()) {
//			return;
//		}
//		
//		allOrders =  allOrders.stream()
//		         			  .filter(e -> (e.getOrderDateTime().toLocalDate()).equals(LocalDate.now()))
//		         			  .collect(Collectors.toList());
//		
//		DecimalFormat df = new DecimalFormat("#.##");	
//		
//		Double totalSalesPriceForAllOrders = 0.0;
//		Double totalCostPriceForAllOrders = 0.0;
//		Integer noOfOrders = 0;
//		
//	    Map<Integer, ProductDTOV3> allProducts = new LinkedHashMap<>();
//	    
//	    Map<String, RevenueDTO> revenueBreakdownMap = new LinkedHashMap<>();
//	    
//	    Set<Integer> countCustomer = new HashSet<>();
//					 
//		for(Orders order : allOrders) {
//					 
//			 List<OrderDetail> details = order.getDetails();
//			 			 
//			 totalSalesPriceForAllOrders += details.stream()
//					  							  .mapToDouble(e2 -> e2.getQuantity() * e2.getProduct().getPrice())
//					  							  .sum();
//			 
//			 totalCostPriceForAllOrders += details.stream()
//												  .mapToDouble(e2 -> e2.getQuantity() * e2.getProduct().getCostPrice())
//												  .sum();
//			 
//			 noOfOrders++;
//			 
//			 
//			 details.stream()
//			 		.forEach(e -> {
//			 			
//			 			ProductDTOV3 pdv3;
//			 			
//			 			if(allProducts.containsKey(e.getProduct().getProductId())) {
//			 				pdv3 = allProducts.get(e.getProduct().getProductId());
//			 				pdv3.setNoOfProductsSold(pdv3.getNoOfProductsSold() + e.getQuantity());
//			 				
//			 			} else {
//			 				pdv3 = new ProductDTOV3();
//			 				pdv3.setCategoryName(e.getProduct().getCategory().getCategoryName());
//			 				pdv3.setProductID(e.getProduct().getProductId());
//			 				pdv3.setNoOfProductsSold(e.getQuantity());
//			 				pdv3.setTotalSales(e.getQuantity() * e.getProduct().getPrice());
//			 				
//			 			}
//			 			
//			 			allProducts.put(e.getProduct().getProductId(), pdv3);
//			 			
//			 			RevenueDTO rdt;
//			 			
//			 			if(revenueBreakdownMap.containsKey(e.getProduct().getCategory().getCategoryName())) {
//			 				rdt = revenueBreakdownMap.get(e.getProduct().getCategory().getCategoryName());
//			 				rdt.setCategorywiseTotalRevenue(rdt.getCategorywiseTotalRevenue() + (e.getQuantity() * 
//			 						(e.getProduct().getPrice() - e.getProduct().getCostPrice())));
//			 				
//			 			} else {
//			 				rdt = new RevenueDTO();
//			 				rdt.setCategoryName(e.getProduct().getCategory().getCategoryName());
//			 				rdt.setCategorywiseTotalRevenue(e.getQuantity() * 
//			 						(e.getProduct().getPrice() - e.getProduct().getCostPrice()));
//			 				
//			 			}
//			 			
//			 			revenueBreakdownMap.put(rdt.getCategoryName(), rdt);
//			 			
//			 		});
//			 
//			 countCustomer.add(order.getCustomer().getUserid());
//			 
//			 
//		}
//		
//		
//		Double avgOrderValue = Double.valueOf(df.format(totalSalesPriceForAllOrders / noOfOrders));
//		
//		Double otherExpenses = ((new Random().nextDouble(1, 6))/100) * totalSalesPriceForAllOrders;
//		
//		Double totalRevenueGenerated = totalSalesPriceForAllOrders - totalCostPriceForAllOrders - otherExpenses;
//		
//		List<ProductDTOV3> topTenProducts = new ArrayList<>();
//		
//		List<Map.Entry<Integer, ProductDTOV3>> list = new ArrayList<>(allProducts.entrySet());
//		
//		list.sort((c1, c2) -> c2.getValue().getNoOfProductsSold() - c1.getValue().getNoOfProductsSold());
//		
//		int count = 0;
//		
//		for(Map.Entry<Integer, ProductDTOV3> pd : list) {
//			topTenProducts.add(pd.getValue());
//			count++;
//			if(count > 10) break;
//		}
//		
//		
//		List<RevenueDTO> revenueBreakdownList = new ArrayList<>();
//		
//		for(Map.Entry<String, RevenueDTO> re : revenueBreakdownMap.entrySet()) {
//			
//			RevenueDTO rdto =  re.getValue();
//			
//			Double revenuePercentage = ((rdto.getCategorywiseTotalRevenue() / totalRevenueGenerated) * 100);
//					
//			String formatedPercentage = df.format(revenuePercentage);			
//			rdto.setRevenuePercentage(formatedPercentage + "%");
//			
//			revenueBreakdownList.add(rdto);
//		}
//		
//		
//		String conversionRate = df.format((countCustomer.size() / cRepo.findAll().size()) * 100) + "%";
//		
//		
//		Optional<DaywiseSalesData> op = sdRepo.findByDate(LocalDate.now());
//		
//		DaywiseSalesData dsd;
//		
//		if(op.isEmpty()) {
//			dsd = new DaywiseSalesData();
//			
//		} else {
//			dsd = op.get();
//		}
//		
//		dsd.setDate(LocalDate.now());
//		dsd.setNoOfOrders(noOfOrders);
//		dsd.setTotalSalesAmount(totalSalesPriceForAllOrders);
//		dsd.setTotalRevenue(totalRevenueGenerated);
//		dsd.setAvgOrderValue(avgOrderValue);
//		dsd.setRevenueBreakdown(revenueBreakdownList);
//		dsd.setTopSellingProducts(topTenProducts);
//		dsd.setConversionRate(conversionRate);
//		
//		sdRepo.save(dsd);
//		
//	}
//
//
//	@Override
//	public DaywiseSalesData getTodaySalesAnalysis() throws SalesAnalysisNotFoundException{
//		
//		doTodaySalesAnalysis();
//		
//		Optional<DaywiseSalesData> op = sdRepo.findByDate(LocalDate.now());
//		
//		if(op.isEmpty()) {
//			throw new SalesAnalysisNotFoundException("No analysis found...");
//		}
//			
//		return op.get();
//		
//	}
//
//
//	@Override
//	public DaywiseSalesData getSalesAnalysisOfDate(LocalDate targetDate) throws SalesAnalysisNotFoundException {
//		
//		if(targetDate.isAfter(LocalDate.now())) {
//			throw new SalesAnalysisNotFoundException("Invalid date");
//		}
//		
//		Optional<DaywiseSalesData> op = sdRepo.findByDate(targetDate);
//		
//		if(op.isEmpty()) {
//			throw new SalesAnalysisNotFoundException("No analysis found...");
//		}
//		
//		return op.get();
//	}
//
//
//	@Override
//	public SalesAnalysisDTO getSalesAnalysisOfLastWeek() throws SalesAnalysisNotFoundException {
//		
//		LocalDate today = LocalDate.now();
//		LocalDate startDate = today.minusDays(7);
//		
//		List<DaywiseSalesData> list = sdRepo.findAll();
//		
//		list = list.stream()
//				   .filter(e -> (!e.getDate().isAfter(today) && !e.getDate().isBefore(startDate)) ? true : false)
//				   .collect(Collectors.toList());
//		
//		if(list.isEmpty()) {
//			throw new SalesAnalysisNotFoundException("No sales data found...");
//		}
//		
//		
//		Double TotalSalesAmountInLastWeek = 0.0;	
//		Integer noOfOrdersInLastWeek = 0;
//	    Double avgOrderValueInLastWeek = 0.0;
//		Double totalRevenueInLastWeek = 0.0;
//		List<ProductDTOV3> topSellingProductsInLastWeek = new ArrayList<>();
//		List<RevenueDTO> revenueBreakdownInLastWeek = new ArrayList<>();
//		
//		
//		
//		for(DaywiseSalesData dsd : list) {
//			TotalSalesAmountInLastWeek += dsd.getTotalSalesAmount();
//			noOfOrdersInLastWeek += dsd.getNoOfOrders();
//			avgOrderValueInLastWeek += dsd.getAvgOrderValue();
//			totalRevenueInLastWeek += dsd.getTotalRevenue();
//			topSellingProductsInLastWeek.addAll(dsd.getTopSellingProducts());
//			revenueBreakdownInLastWeek.addAll(dsd.getRevenueBreakdown());
//		}
//		
//
//		List<ProductDTOV3> finalizedTopSellingProductsInLastWeek 
//		      = topSellingProductsInLastWeek.stream()
//										    .collect(Collectors.groupingBy(p -> p.getProductID()))
//										    .entrySet().stream()
//										    .map(entry -> {
//										    	
//										        Integer productId = entry.getKey();
//										        List<ProductDTOV3> productDTOV3s = entry.getValue();
//										        int noOfProductsSold = 0;
//										        double totalSales = 0.0;
//										        String categoryName = productDTOV3s.get(0).getCategoryName();
//										        
//										        for (ProductDTOV3 productDTOV3 : productDTOV3s) {
//										            noOfProductsSold += productDTOV3.getNoOfProductsSold();
//										            totalSales += productDTOV3.getTotalSales();
//										        }
//										        return new ProductDTOV3(productId, noOfProductsSold, totalSales, categoryName);
//										    })
//										    .sorted((c1, c2) -> c2.getNoOfProductsSold() - c1.getNoOfProductsSold())
//										    .limit(10)
//										    .collect(Collectors.toList());
//
//		
//		
//		List<RevenueDTO> finalizedRevenueBreakdownInLastWeek 
//				= revenueBreakdownInLastWeek.stream()
//											.collect(Collectors.groupingBy(e -> e.getCategoryName()))
//											.entrySet().stream()
//											.map(entry -> {
//												
//												Double categorywiseTotalRevenue = 0.0;
//												
//												List<RevenueDTO> revenueDTOs =  entry.getValue();
//												String categoryName = revenueDTOs.get(0).getCategoryName();
//												
//												for(RevenueDTO rdt : revenueDTOs) {
//													categorywiseTotalRevenue += rdt.getCategorywiseTotalRevenue();
//												}
//												
//												return new RevenueDTO(categoryName, categorywiseTotalRevenue, null);
//											})
//											.collect(Collectors.toList());
//			
//		DecimalFormat df = new DecimalFormat("#.##");	
//		
//		Double totalRevenue = totalRevenueInLastWeek;
//		
//		finalizedRevenueBreakdownInLastWeek = 
//				finalizedRevenueBreakdownInLastWeek.stream()	
//												   .map(e -> {
//													   e.setRevenuePercentage(df.format(e.getCategorywiseTotalRevenue() / totalRevenue) + "%") ;
//													   return e;
//												   })
//												   .collect(Collectors.toList());
//		
//		
//		List<Orders> orders = oRepo.findAll();
//		
//		orders = orders.stream()
//					   .filter(e -> (!e.getOrderDateTime().toLocalDate().isAfter(today) && !e.getOrderDateTime().toLocalDate().isBefore(startDate)) ? true : false)
//					   .collect(Collectors.toList());
//		
//		Set<Integer> customerCount = new HashSet<>();
//		
//		orders.stream()
//		      .forEach(o -> customerCount.add(o.getCustomer().getUserid()));
//		
//		
//		String conversionRateInLastWeek = df.format((customerCount.size() / cRepo.findAll().size()) * 100) + "%";
//		
//		
//		SalesAnalysisDTO sadt = new SalesAnalysisDTO();
//		sadt.setAvgOrderValue(avgOrderValueInLastWeek);
//		sadt.setConversionRate(conversionRateInLastWeek);
//		sadt.setNoOfOrders(noOfOrdersInLastWeek);
//		sadt.setRevenueBreakdown(finalizedRevenueBreakdownInLastWeek);
//		sadt.setTopSellingProducts(finalizedTopSellingProductsInLastWeek);
//		sadt.setTotalSalesAmount(TotalSalesAmountInLastWeek);
//		sadt.setTotalRevenue(totalRevenueInLastWeek);
//		
//		
//		return sadt;
//	}
//	
//	
//	@Override
//	public SalesAnalysisDTO getSalesAnalysisOfLastMonth() throws SalesAnalysisNotFoundException {
//		
//		LocalDate firstDate = (LocalDate.now().withMonth(LocalDate.now().getMonth().minus(1).getValue()).withDayOfMonth(1));
//		
//		LocalDate lastDate = firstDate.withDayOfMonth(firstDate.getMonth().length(firstDate.isLeapYear()));
//	
//		if(lastDate.getMonthValue() == 1) {
//			firstDate = firstDate.withYear(firstDate.getYear() - 1);
//			lastDate = lastDate.withYear(lastDate.getYear() - 1);
//		}
//		
//		LocalDate modifiedFirstDate = firstDate;
//		LocalDate modifiedLastDate = lastDate;
//		
//		List<DaywiseSalesData> list = sdRepo.findAll();
//		
//		list = list.stream()
//				   .filter(e -> (!e.getDate().isAfter(modifiedLastDate) && !e.getDate().isBefore(modifiedFirstDate)) ? true : false)
//				   .collect(Collectors.toList());
//		
//		if(list.isEmpty()) {
//			throw new SalesAnalysisNotFoundException("No sales data found...");
//		}
//		
//		Double TotalSalesAmountInLastMonth = 0.0;	
//		Integer noOfOrdersInLastMonth = 0;
//	    Double avgOrderValueInLastMonth = 0.0;
//		Double totalRevenueInLastMonth = 0.0;
//		List<ProductDTOV3> topSellingProductsInLastMonth = new ArrayList<>();
//		List<RevenueDTO> revenueBreakdownInLastMonth = new ArrayList<>();
//		
//		
//		
//		for(DaywiseSalesData dsd : list) {
//			TotalSalesAmountInLastMonth += dsd.getTotalSalesAmount();
//			noOfOrdersInLastMonth += dsd.getNoOfOrders();
//			avgOrderValueInLastMonth += dsd.getAvgOrderValue();
//			totalRevenueInLastMonth += dsd.getTotalRevenue();
//			topSellingProductsInLastMonth.addAll(dsd.getTopSellingProducts());
//			revenueBreakdownInLastMonth.addAll(dsd.getRevenueBreakdown());
//		}
//		
//
//		List<ProductDTOV3> finalizedTopSellingProductsInLastMonth
//		      = topSellingProductsInLastMonth.stream()
//										    .collect(Collectors.groupingBy(p -> p.getProductID()))
//										    .entrySet().stream()
//										    .map(entry -> {
//										    	
//										        Integer productId = entry.getKey();
//										        List<ProductDTOV3> productDTOV3s = entry.getValue();
//										        int noOfProductsSold = 0;
//										        double totalSales = 0.0;
//										        String categoryName = productDTOV3s.get(0).getCategoryName();
//										        
//										        for (ProductDTOV3 productDTOV3 : productDTOV3s) {
//										            noOfProductsSold += productDTOV3.getNoOfProductsSold();
//										            totalSales += productDTOV3.getTotalSales();
//										        }
//										        return new ProductDTOV3(productId, noOfProductsSold, totalSales, categoryName);
//										    })
//										    .sorted((c1, c2) -> c2.getNoOfProductsSold() - c1.getNoOfProductsSold())
//										    .limit(10)
//										    .collect(Collectors.toList());
//
//		
//		
//		List<RevenueDTO> finalizedRevenueBreakdownInLastMonth 
//				= revenueBreakdownInLastMonth.stream()
//											.collect(Collectors.groupingBy(e -> e.getCategoryName()))
//											.entrySet().stream()
//											.map(entry -> {
//												
//												Double categorywiseTotalRevenue = 0.0;
//												
//												List<RevenueDTO> revenueDTOs =  entry.getValue();
//												String categoryName = revenueDTOs.get(0).getCategoryName();
//												
//												for(RevenueDTO rdt : revenueDTOs) {
//													categorywiseTotalRevenue += rdt.getCategorywiseTotalRevenue();
//												}
//												
//												return new RevenueDTO(categoryName, categorywiseTotalRevenue, null);
//											})
//											.collect(Collectors.toList());
//											
//		
//		DecimalFormat df = new DecimalFormat("#.##");	
//		
//		Double totalRevenue = totalRevenueInLastMonth;
//		
//		finalizedRevenueBreakdownInLastMonth = 
//				finalizedRevenueBreakdownInLastMonth.stream()	
//												   .map(e -> {
//													   e.setRevenuePercentage(df.format(e.getCategorywiseTotalRevenue() / totalRevenue) + "%") ;
//													   return e;
//												   })
//												   .collect(Collectors.toList());
//		
//		
//		List<Orders> orders = oRepo.findAll();
//		
//		orders = orders.stream()
//					   .filter(e -> (!e.getOrderDateTime().toLocalDate().isAfter(modifiedLastDate) && !e.getOrderDateTime().toLocalDate().isBefore(modifiedFirstDate)) ? true : false)
//					   .collect(Collectors.toList());
//		
//		Set<Integer> customerCount = new HashSet<>();
//		
//		orders.stream()
//		      .forEach(o -> customerCount.add(o.getCustomer().getUserid()));
//
//		
//		String conversionRateInLastMonth = df.format((customerCount.size() / cRepo.findAll().size()) * 100) + "%";
//		
//		
//		SalesAnalysisDTO sadt = new SalesAnalysisDTO();
//		sadt.setAvgOrderValue(avgOrderValueInLastMonth);
//		sadt.setConversionRate(conversionRateInLastMonth);
//		sadt.setNoOfOrders(noOfOrdersInLastMonth);
//		sadt.setRevenueBreakdown(finalizedRevenueBreakdownInLastMonth);
//		sadt.setTopSellingProducts(finalizedTopSellingProductsInLastMonth);
//		sadt.setTotalSalesAmount(TotalSalesAmountInLastMonth);
//		sadt.setTotalRevenue(totalRevenueInLastMonth);
//		
//		
//		return sadt;
//	}
//	
//
//	@Override
//	public SalesAnalysisDTO getSalesAnalysisOfYear(Integer targetYear) throws SalesAnalysisNotFoundException {
//		
//		if(targetYear > LocalDate.now().getYear()) {
//			throw new SalesAnalysisNotFoundException("Invalid year");
//		}
//		
//		
//		LocalDate firstDate = LocalDate.of(targetYear, 1, 1);		
//		LocalDate lastDate = LocalDate.of(targetYear, 12, 31);
//	
//		if(lastDate.getMonthValue() == 1) {
//			firstDate = firstDate.withYear(firstDate.getYear() - 1);
//			lastDate = lastDate.withYear(lastDate.getYear() - 1);
//		}
//		
//		LocalDate modifiedFirstDate = firstDate;
//		LocalDate modifiedLastDate = lastDate;
//		
//		List<DaywiseSalesData> list = sdRepo.findAll();
//		
//		list = list.stream()
//				   .filter(e -> (!e.getDate().isAfter(modifiedLastDate) && !e.getDate().isBefore(modifiedFirstDate)) ? true : false)
//				   .collect(Collectors.toList());
//		
//		if(list.isEmpty()) {
//			throw new SalesAnalysisNotFoundException("No sales data found...");
//		}
//		
//		Double TotalSalesAmountInTheYear = 0.0;	
//		Integer noOfOrdersInTheYear = 0;
//	    Double avgOrderValueInTheYear = 0.0;
//		Double totalRevenueInTheYear = 0.0;
//		List<ProductDTOV3> topSellingProductsInTheYear = new ArrayList<>();
//		List<RevenueDTO> revenueBreakdownInTheYear = new ArrayList<>();
//		
//		
//		
//		for(DaywiseSalesData dsd : list) {
//			TotalSalesAmountInTheYear += dsd.getTotalSalesAmount();
//			noOfOrdersInTheYear += dsd.getNoOfOrders();
//			avgOrderValueInTheYear += dsd.getAvgOrderValue();
//			totalRevenueInTheYear += dsd.getTotalRevenue();
//			topSellingProductsInTheYear.addAll(dsd.getTopSellingProducts());
//			revenueBreakdownInTheYear.addAll(dsd.getRevenueBreakdown());
//		}
//		
//
//		List<ProductDTOV3> finalizedTopSellingProductsInTheYear 
//		      = topSellingProductsInTheYear.stream()
//										    .collect(Collectors.groupingBy(p -> p.getProductID()))
//										    .entrySet().stream()
//										    .map(entry -> {
//										    	
//										        Integer productId = entry.getKey();
//										        List<ProductDTOV3> productDTOV3s = entry.getValue();
//										        int noOfProductsSold = 0;
//										        double totalSales = 0.0;
//										        String categoryName = productDTOV3s.get(0).getCategoryName();
//										        
//										        for (ProductDTOV3 productDTOV3 : productDTOV3s) {
//										            noOfProductsSold += productDTOV3.getNoOfProductsSold();
//										            totalSales += productDTOV3.getTotalSales();
//										        }
//										        return new ProductDTOV3(productId, noOfProductsSold, totalSales, categoryName);
//										    })
//										    .sorted((c1, c2) -> c2.getNoOfProductsSold() - c1.getNoOfProductsSold())
//										    .limit(10)
//										    .collect(Collectors.toList());
//
//		
//		
//		List<RevenueDTO> finalizedRevenueBreakdownInTheYear 
//				= revenueBreakdownInTheYear.stream()
//											.collect(Collectors.groupingBy(e -> e.getCategoryName()))
//											.entrySet().stream()
//											.map(entry -> {
//												
//												Double categorywiseTotalRevenue = 0.0;
//												
//												List<RevenueDTO> revenueDTOs =  entry.getValue();
//												String categoryName = revenueDTOs.get(0).getCategoryName();
//												
//												for(RevenueDTO rdt : revenueDTOs) {
//													categorywiseTotalRevenue += rdt.getCategorywiseTotalRevenue();
//												}
//												
//												return new RevenueDTO(categoryName, categorywiseTotalRevenue, null);
//											})
//											.collect(Collectors.toList());
//		
//		
//		DecimalFormat df = new DecimalFormat("#.##");	
//		
//		Double totalRevenue = totalRevenueInTheYear;
//		
//		finalizedRevenueBreakdownInTheYear = 
//				finalizedRevenueBreakdownInTheYear.stream()	
//												   .map(e -> {
//													   e.setRevenuePercentage(df.format(e.getCategorywiseTotalRevenue() / totalRevenue) + "%") ;
//													   return e;
//												   })
//												   .collect(Collectors.toList());
//											
//		
//		
//		List<Orders> orders = oRepo.findAll();
//		
//		orders = orders.stream()
//					   .filter(e -> (!e.getOrderDateTime().toLocalDate().isAfter(modifiedLastDate) && !e.getOrderDateTime().toLocalDate().isBefore(modifiedFirstDate)) ? true : false)
//					   .collect(Collectors.toList());
//		
//		Set<Integer> customerCount = new HashSet<>();
//		
//		orders.stream()
//		      .forEach(o -> customerCount.add(o.getCustomer().getUserid()));
//		
//		String conversionRateInTheYear = df.format((customerCount.size() / cRepo.findAll().size()) * 100) + "%";
//		
//		
//		SalesAnalysisDTO sadt = new SalesAnalysisDTO();
//		sadt.setAvgOrderValue(avgOrderValueInTheYear);
//		sadt.setConversionRate(conversionRateInTheYear);
//		sadt.setNoOfOrders(noOfOrdersInTheYear);
//		sadt.setRevenueBreakdown(finalizedRevenueBreakdownInTheYear);
//		sadt.setTopSellingProducts(finalizedTopSellingProductsInTheYear);
//		sadt.setTotalSalesAmount(TotalSalesAmountInTheYear);
//		sadt.setTotalRevenue(totalRevenueInTheYear);
//		
//		
//		return sadt;
//	}
//
//
//	@Override
//	public List<ProductDTOV4> getBestsellingProductByRatingInDuration(LocalDate startDate, LocalDate endDate)
//			throws SalesAnalysisNotFoundException {
//		
//		if(startDate.isAfter(endDate)) {
//			throw new SalesAnalysisNotFoundException("Invalid time period");
//		}
//		
//		
//		List<DaywiseSalesData> list = sdRepo.findAll();
//		
//		list = list.stream()
//				   .filter(e -> (!e.getDate().isAfter(endDate) && !e.getDate().isBefore(startDate)) ? true : false)
//				   .collect(Collectors.toList());
//		
//		if(list.isEmpty()) {
//			throw new SalesAnalysisNotFoundException("No sales data found...");
//		}
//		
//		
//		List<ProductDTOV3> topSellingProductsInTheDuration = new ArrayList<>();
//		
//			
//		for(DaywiseSalesData dsd : list) {
//			topSellingProductsInTheDuration.addAll(dsd.getTopSellingProducts());
//		}
//		
//
//		topSellingProductsInTheDuration 
//		       = topSellingProductsInTheDuration.stream()
//										    .collect(Collectors.groupingBy(p -> p.getProductID()))
//										    .entrySet().stream()
//										    .map(entry -> {
//										    	
//										        Integer productId = entry.getKey();
//										        List<ProductDTOV3> productDTOV3s = entry.getValue();
//										        int noOfProductsSold = 0;
//										        double totalSales = 0.0;
//										        String categoryName = productDTOV3s.get(0).getCategoryName();
//										        
//										        for (ProductDTOV3 productDTOV3 : productDTOV3s) {
//										            noOfProductsSold += productDTOV3.getNoOfProductsSold();
//										            totalSales += productDTOV3.getTotalSales();
//										        }
//										        return new ProductDTOV3(productId, noOfProductsSold, totalSales, categoryName);
//										    })
//										    .sorted((c1, c2) -> c2.getNoOfProductsSold() - c1.getNoOfProductsSold())
//										    .limit(10)
//										    .collect(Collectors.toList());
//
//		
//		List<ProductDTOV4> finalizedtopSellingProductsInTheDuration
//								= topSellingProductsInTheDuration
//								  .stream()
//								  .map(p -> {
//									  
//									    ProductDTOV4 productV4 = new ProductDTOV4();
//									    
//								        productV4.setProductID(p.getProductID());
//								        productV4.setNoOfProductsSold(p.getNoOfProductsSold());
//								        productV4.setTotalSales(p.getTotalSales());
//								        productV4.setCategoryName(p.getCategoryName());
//								        Double avgRating = pRepo.findById(p.getProductID()).get().getAvgRatings();
//								        productV4.setAvgRatings(avgRating != null ? avgRating : 0.0);
//								        return productV4;
//								  })
//								  .sorted((p1, p2) -> Double.compare(p2.getAvgRatings(), p1.getAvgRatings()))
//								  .collect(Collectors.toList());
//		
//		return finalizedtopSellingProductsInTheDuration;
//	}
//	
//
//	@Override
//	public Map<String, ProductDTOV5> getBestsellingProductForEachCategoryInDuration(LocalDate startDate, LocalDate endDate)
//			throws OrderException {
//		
//		if(startDate.isAfter(endDate)) {
//			throw new OrderException("Invalid date");
//		}
//		
//		List<Orders> orders =  oRepo.findAll();
//		
//		if(orders.isEmpty()) {
//			throw new OrderException("No order found...");
//		}
//		
//		
//		orders = orders.stream()
//					   .filter(e -> !e.getOrderDateTime().toLocalDate().isAfter(endDate) 
//							   		&& !e.getOrderDateTime().toLocalDate().isBefore(startDate))
//					   .collect(Collectors.toList());
//		
//		if(orders.isEmpty()) {
//			throw new OrderException("No order found...");
//		}
//		
//		
//		Map<String, List<ProductDTOV5>> categorywiseProductList = new LinkedHashMap<>();
//		
//		Map<String, ProductDTOV5> finalCategorywiseBestSellingProduct = new LinkedHashMap<>();
//		
//		for(Orders order : orders) {			
//			List<OrderDetail> details = order.getDetails();
//			
//			 details.stream()
//					.map(e1 -> {
//						
//						Product product = e1.getProduct();
//						
//						Integer categoryID = product.getCategory().getCategoryId();
//						String categoryName = product.getCategory().getCategoryName();
//						Integer productID = product.getProductId();
//						String productName = product.getProductName();
//						Double costPrice = product.getCostPrice();
//						Double salePrice = product.getPrice();
//						Integer noOfProducts = e1.getQuantity();
//						Double revenueGenerated = noOfProducts * (salePrice - costPrice);
//						
//						ProductDTOV5 pdv5 = new ProductDTOV5();
//					
//						pdv5.setCategoryID(categoryID);
//						pdv5.setCategoryName(categoryName);
//						pdv5.setCostPrice(costPrice);
//						pdv5.setNoOfProducts(noOfProducts);
//						pdv5.setProductID(productID);
//						pdv5.setProductName(productName);
//						pdv5.setRevenueGenerated(revenueGenerated);
//						pdv5.setSalePrice(salePrice);
//						
//						return pdv5;
//						
//					})
//					.collect(Collectors.groupingBy(e2 -> e2.getCategoryName()))
//					.forEach((cat, pro) -> {
//						
//						if(categorywiseProductList.containsKey(cat)) {
//							List<ProductDTOV5> productList = categorywiseProductList.get(cat);
//							productList.addAll(pro);
//							
//						} else {
//							categorywiseProductList.put(cat, pro);
//						}
//						
//					});
//
//		}
//		
//		
//		categorywiseProductList.entrySet()
//							   .stream()
//							   .forEach(e -> {
//									
//									String categoryName = e.getKey();
//									List<ProductDTOV5> productList = e.getValue();
//									
//									ProductDTOV5 bestSellingProduct = 
//											productList.stream()
//												   .collect(Collectors.groupingBy(e1 -> e1.getProductID()))
//												   .entrySet()
//												   .stream()
//												   .map(e2 -> {
//													   
//													   List<ProductDTOV5> pdv5 = e2.getValue();
//													   Integer categoryID1 = pdv5.get(0).getCategoryID();
//													   String categoryName1 = pdv5.get(0).getCategoryName();
//													   Integer productID1 = pdv5.get(0).getProductID();
//													   String productName1 = pdv5.get(0).getProductName();
//													   Double salePrice1 = pdv5.get(0).getSalePrice();
//													   Double costPrice1 = pdv5.get(0).getCostPrice();
//													   Integer noOfProducts1 = 0;
//													   Double revenueGenerated = 0.0;
//													   
//													   for(ProductDTOV5 p : pdv5) {
//														   noOfProducts1 += p.getNoOfProducts();
//														   revenueGenerated += p.getRevenueGenerated();
//													   }
//													   
//													   ProductDTOV5 pdv = new ProductDTOV5();
//													   pdv.setCategoryID(categoryID1);
//													   pdv.setCategoryName(categoryName1);
//													   pdv.setCostPrice(costPrice1);
//													   pdv.setNoOfProducts(noOfProducts1);
//													   pdv.setProductID(productID1);
//													   pdv.setProductName(productName1);
//													   pdv.setRevenueGenerated(revenueGenerated);
//													   pdv.setSalePrice(salePrice1);
//													   
//													   return pdv;
//												   })
//												   .sorted((c1, c2) -> c2.getNoOfProducts() - c1.getNoOfProducts())
//												   .limit(1)
//												   .collect(Collectors.toList())
//												   .get(0);
//									
//									finalCategorywiseBestSellingProduct.put(categoryName, bestSellingProduct);
//									
//								});
//								
//		
//		
//		return finalCategorywiseBestSellingProduct;
//	}
//	
//	
//

	



	
}
