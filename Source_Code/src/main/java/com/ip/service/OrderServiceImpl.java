package com.ip.service;

import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import com.ip.dto.CancelledDTO;
import com.ip.dto.CartDTOV2;
import com.ip.dto.CartDTOV3;
import com.ip.dto.OrderDTO;
import com.ip.dto.ReturnRequestDTO;
import com.ip.enums.OrderStatus;
import com.ip.exception.CredentialException;
import com.ip.exception.CustomerException;
import com.ip.exception.OrderException;
import com.ip.exception.ProductException;
import com.ip.exception.ShipperException;
import com.ip.exception.SupplierException;
import com.ip.model.CancelledOrders;
import com.ip.model.Cart;
import com.ip.model.CartProductQuantity;
import com.ip.model.Customer;
import com.ip.model.OrderDetail;
import com.ip.model.Orders;
import com.ip.model.Payment;
import com.ip.model.Product;
import com.ip.model.ReturnRequestedOrders;
import com.ip.model.ReturnedOrderDetails;
import com.ip.model.Shipper;
import com.ip.model.Supplier;
import com.ip.repository.CancelledOrderRepo;
import com.ip.repository.CartProductQuantityRepo;
import com.ip.repository.CategoryRepo;
import com.ip.repository.CustomerRepo;
import com.ip.repository.OrdersRepo;
import com.ip.repository.ProductRepo;
import com.ip.repository.ReturnRequestedOrdersRepo;
import com.ip.repository.ShipperRepo;
import com.ip.repository.SupplierRepo;

import jakarta.transaction.Transactional;

@Service
public class OrderServiceImpl implements OrderService {
	
	
	@Autowired
	private CustomerRepo cRepo;
	
	@Autowired
	private OrdersRepo oRepo;
	
	@Autowired
	private CartProductQuantityRepo cpqRepo;
	

	@Autowired
	private SupplierRepo suppRepo;
	
	
	@Autowired
	private ShipperRepo shipRepo;
	
	@Autowired
	private ProductRepo pRepo;
	
	
	@Autowired
	private ReturnRequestedOrdersRepo rroRepo;
	
	@Autowired
	private CancelledOrderRepo canRepo;
	
	
	@Autowired
	private CategoryRepo catRepo;

	
	public String formatString(String string) {
		
		if(string.isBlank() || string.isBlank() || string == null) {
			return string;
		}
		
		return  Character.toUpperCase(string.charAt(0)) + string.substring(1).toLowerCase();		
	}
	
	
	@Override
	public Supplier registerSupplier(Supplier supplier) throws SupplierException {
		
		if(supplier.getSupplierID() != null) {
			throw new SupplierException("You don't need to provide SupplierID, as it is autogenerated");
		}
		
		if(catRepo.findByCategoryName(formatString(supplier.getCategoryName())) == null) {
			throw new SupplierException("Invalid category name");
		}
		
		supplier.setCategoryName(formatString(supplier.getCategoryName()));
		
		return suppRepo.save(supplier);
	}

	
	@Override
	public String changeActiveStatusOfSupplier(Integer supplierID) throws SupplierException {
		
		Optional<Supplier> op = suppRepo.findById(supplierID);
		
		if(op.isEmpty()) {
			throw new SupplierException("Invalid supplierID");
		}
		
		Supplier supplier = op.get();
		
		supplier.setActive(!supplier.getActive());
		
		suppRepo.save(supplier);
		
		return "Active status for the supplier with ID : " + supplier.getSupplierID() + 
				" has changed to " + supplier.getActive();
		
	}

	
	@Override
	public Shipper registerShipper(Shipper shipper) throws ShipperException {
		
		if(shipper.getShipperID() != null) {
			throw new ShipperException("You don't need to provide ShipperID, as it is autogenerated");
		}
		
		return shipRepo.save(shipper);
	}
	
	
	@Override
	public String changeActiveStatusOfShipper(Integer shipperID) throws ShipperException {
		
		Optional<Shipper> op = shipRepo.findById(shipperID);
		
		if(op.isEmpty()) {
			throw new ShipperException("Invalid supplierID");
		}
		
		Shipper shipper = op.get();
		
		shipper.setActive(!shipper.getActive());
		
		shipRepo.save(shipper);
		
		return "Active status for the shipper with ID : " + shipper.getShipperID() + 
				" has changed to " + shipper.getActive();
		
	}
	
	@Override
	public OrderDTO makePurchase(Payment payment) throws SupplierException, ProductException, CustomerException, CredentialException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		Customer customer = cRepo.findByEmail(auth.getName()).get();
		
		Cart cart = customer.getCart();
		
		if(cart == null || cart.getProducts().size() == 0) {
			throw new ProductException("Cart has no product i.e., empty. Please add products to make purchase");
		}

		
		final Orders o = new Orders();
		
		List<Product> products = cart.getProducts();
		
		Set<String> supplierList = new LinkedHashSet<>();		
		List<CartProductQuantity> quantitiesToDelete = new ArrayList<>();
		        	
	    for(Product p : products) {
			
			OrderDetail od = new OrderDetail();
			
			od.setProduct(p);
			
			od.setQuantity(cpqRepo.findByCartIdAndProductId(cart.getCartId(), p.getProductId()).getProductQuantity());
			quantitiesToDelete.add(cpqRepo.findByCartIdAndProductId(cart.getCartId(), p.getProductId()));
			
			
			//Assign Supplier
			//Find all the suppliers
			List<Supplier> suppliers =  suppRepo.findAll();
			
			if(suppliers.isEmpty()) {
				throw new SupplierException("No supplier found...");
			}
			
			//Filter out the suppliers who are active and supplies the products of same category as the product belongs to
			suppliers = suppliers.stream()
						         .filter(e -> e.getActive() == true && e.getCategoryName().equalsIgnoreCase(p.getCategory().getCategoryName()))
						         .collect(Collectors.toList());
			
			if(suppliers.isEmpty()) {
				throw new SupplierException("No supplier found...");
			}

			
			//Randomly selecting a supplier from the list of suppliers
			Supplier supplier = suppliers.get(new Random().nextInt(suppliers.size()));
			
			supplierList.add(supplier.getCompanyName());

			//Associate supplier and orderdetails with each other
			od.setSupplier(supplier);
			supplier.getDetails().add(od);
			
			//Associate order and orderdetails with each other
			od.setOrder(o);
			o.getDetails().add(od);
			  
			
		}
	    
		
		//Associating the payment and orders with each other 
		o.setPayment(payment);
		payment.setOrder(o);
		

		List<CartDTOV2> list = new ArrayList<>();
		List<Integer> quantList = new ArrayList<>();
		List<Double> priceList = new ArrayList<>();
		
		products.forEach(c1 -> {
			CartDTOV2 cv2 = new CartDTOV2();
			cv2.setCartId(cart.getCartId());
			cv2.setCategoryName(c1.getCategory().getCategoryName());
			cv2.setImageUrl(c1.getProductImage());
			cv2.setPrice(c1.getPrice());
			
			cv2.setProductId(c1.getProductId());
			cv2.setProductName(c1.getProductImage());
			Integer quantity = cpqRepo.findByCartIdAndProductId(customer.getCart().getCartId(), c1.getProductId()).getProductQuantity();
			cv2.setQuantity(quantity);
			quantList.add(quantity);
			priceList.add(c1.getPrice() * quantity);
			list.add(cv2);
		});
		
		CartDTOV3 cv3 = new CartDTOV3();
		cv3.setList(list);
		cv3.setQuantity(quantList.stream().reduce(0, (s, e) -> s + e));
		cv3.setSubtotal(priceList.stream().reduce(0.0, (s, e) -> s + e));
		
		o.setTotal_order_amount(cv3.getSubtotal());
		
		//Clearing the cart
		products.clear();
		cart.setProducts(products);
		
		//Associating customer with order
		o.setCustomer(customer);
		customer.getOrders().add(o);
		
		//Setting order status
		o.setOrderStatus(OrderStatus.PENDING);
		
		//Retrieving all available shippers
		List<Shipper> shippers =  shipRepo.findAll();
		
		//Filter out shippers who are active
		shippers = shippers.stream()
						   .filter(e -> e.getActive() == true)
						   .collect(Collectors.toList());
		
		//Randomly selecting a shipper from the list of shippers
		Shipper shipper = shippers.get(new Random().nextInt(shippers.size()));
		
		//Associating shipper and orders with each other
		o.setShipper(shipper);
		shipper.getOrders().add(o);
		
		//Assigning dynamically generated shipDateTime
		LocalDateTime shipDateTime =  o.getOrderDateTime().toLocalDate()
									                      .plusDays(1)
									                      .atTime(LocalTime.of(new Random().nextInt(10, 21), 
									                    		  new Random().nextInt(60), new Random().nextInt(60)));
		o.setShipDateTime(shipDateTime);
		
		//Assigning dynamically generated deliveryDateTime
		LocalDateTime deliveryDateTime =  o.getOrderDateTime().toLocalDate()
                											  .plusDays(5)
                											  .atTime(LocalTime.of(new Random().nextInt(10, 21), 
                													  new Random().nextInt(60), new Random().nextInt(60)));
		o.setDeliveryDateTime(deliveryDateTime);

		//Persist the order object
		Orders o1 = oRepo.save(o);
		
		System.out.println("test5");
		
		cpqRepo.deleteAll(quantitiesToDelete);
	    quantitiesToDelete.clear();
		
		//Create OrderDTO which contains all the required informations of the saved order
		OrderDTO od = new OrderDTO();
		
		od.setCustomerID(customer.getUserid());
		od.setOrderID(o1.getOrderID());
		od.setOrderDateTime(o1.getOrderDateTime());
		od.setShipDateTime(shipDateTime);
		od.setDeliveryDateTime(deliveryDateTime);
		od.setShipper(shipper.getCompanyName());
		od.setSuppliers(String.join(",", supplierList));
		od.setDetails(o1.getDetails());
		od.setTotal_order_amount(o1.getTotal_order_amount());

		return od;
		
	}

	
	@Override
	public CancelledDTO cancelOrder(Integer orderID) throws OrderException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		Customer customer = cRepo.findByEmail(auth.getName()).get();
		
		if(customer.getOrders() == null || customer.getOrders().isEmpty()) {
			throw new OrderException("No order is made by the customer");
		}
		
		Orders od = customer.getOrders().stream()
										.filter(o -> o.getOrderID() == orderID)
										.collect(Collectors.toList())
										.get(0);
		
		if(od == null) {
			throw new OrderException("Invalid orderId");
		}
		
		if(od.getOrderStatus().equals(OrderStatus.CANCELLED_AND_REFUND_IN_PROGESS) ||
				od.getOrderStatus().equals(OrderStatus.RETURN_IN_PROGRESS) || 
				od.getOrderStatus().equals(OrderStatus.RETURNED_AND_REFUND_IN_PROGESS) || 
				od.getOrderStatus().equals(OrderStatus.REFUNDED) ) {
			throw new OrderException("Invalid action...");
		}
		
		
		if(!LocalDateTime.now().isBefore(od.getDeliveryDateTime())) {
			throw new OrderException("Products are already being delivered so you can't cancel the order now, if not satisfied please return");
		}
		
		if(!LocalDateTime.now().isBefore(od.getShipDateTime())) {
			throw new OrderException("Products are already being shipped so you can't cancel the order now, if not satisfied please return after receiving it");
		}
		
		od.setCancelled(true);
		
		od.getDetails().stream()
					   .forEach(d -> {
						  Product pr = pRepo.findById(d.getProduct().getProductId()).get();					  
						  pr.setStockQuantity(pr.getStockQuantity() + d.getQuantity());
						  pRepo.save(pr);
					   });
		
		CancelledOrders cOrders = new CancelledOrders();
		
		cOrders.setOrderID(orderID);
		cOrders.setCancelledON(LocalDateTime.now());
		
		LocalDateTime refundDateTime = cOrders.getCancelledON().toLocalDate()
				  												.plusDays(7)
				  												.atTime(LocalTime.of(new Random().nextInt(10, 21), 
				  														new Random().nextInt(60), new Random().nextInt(60)));
		
		cOrders.setRefundON(refundDateTime);
		
		
		od.setOrderStatus(OrderStatus.CANCELLED_AND_REFUND_IN_PROGESS);
		
		canRepo.save(cOrders);
		oRepo.save(od);
		
		
		CancelledDTO dto = new CancelledDTO();
		
		dto.setOrderID(orderID);
		dto.setCancelledON(cOrders.getCancelledON());
		dto.setCancelledON(cOrders.getRefundON());
		dto.setStatus(OrderStatus.CANCELLED_AND_REFUND_IN_PROGESS);
		
		
		return dto;
		
	}
	
	
	@Override
	@Scheduled(fixedRate = 300000)
	public void updateOrderStatus() {
		
		
		List<Orders> orders = oRepo.findAll();
		
		if(!orders.isEmpty()) {
			
			for(Orders od : orders) {
				
				LocalDateTime shipDateTime = od.getShipDateTime();				
				LocalDateTime deliveryDateTime = od.getDeliveryDateTime();
				
				if(od.getCancelled()) {
					
					CancelledOrders cOrder = canRepo.findById(od.getOrderID()).get();
					
					if(!LocalDateTime.now().isBefore(cOrder.getRefundON())) {
						od.setOrderStatus(OrderStatus.REFUNDED);
					}
					
					
				} else if(od.getReturnRequested()) {
					
					ReturnRequestedOrders rOrder = rroRepo.findById(od.getOrderID()).get();
					
					if(!LocalDateTime.now().isBefore(rOrder.getFulfillON()) && 
							LocalDateTime.now().isBefore(rOrder.getRefundON())) {
						od.setOrderStatus(OrderStatus.RETURNED_AND_REFUND_IN_PROGESS);
						
					} else if(!LocalDateTime.now().isBefore(rOrder.getRefundON())) {
						od.setOrderStatus(OrderStatus.REFUNDED);
					}
					
				} else if(!LocalDateTime.now().isBefore(deliveryDateTime)) {
					od.setOrderStatus(OrderStatus.DELIVERED);
					
				} else if(!LocalDateTime.now().isBefore(shipDateTime) && LocalDateTime.now().isBefore(deliveryDateTime)) {
					od.setOrderStatus(OrderStatus.SHIPPED);
				}
				
				
				oRepo.save(od);
				
			}
			
		}
	
		
	}

	
	@Override
	public String checkOrderStatus(Integer orderID) throws OrderException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		String role = new ArrayList<>(auth.getAuthorities()).get(0).toString();
		
		Orders od;
		
		if(role.equals("ROLE_CUSTOMER")) {
			
			Customer customer = cRepo.findByEmail(auth.getName()).get();
			
			if(customer.getOrders() == null || customer.getOrders().isEmpty()) {
				throw new OrderException("No order is made by the customer");
			}
			
			 List<Orders> list = customer.getOrders().stream()
									 				 .filter(o -> o.getOrderID().equals(orderID))
									 			     .collect(Collectors.toList());
			
			if(list.isEmpty()) {
				throw new OrderException("Invalid orderID");
			}
			
			od = list.get(0);

		} else {
			
			
			Optional<Orders> op = oRepo.findById(orderID);
			
			if(op.isEmpty()) {
				throw new OrderException("Invalid orderID");
			}
			
			od = op.get();
		}
		
		return od.getOrderStatus().toString();
		
	}
	
	
	@Override
	public ReturnRequestDTO submitReturnRequest(Integer orderID) throws OrderException {
		
		Authentication auth =  SecurityContextHolder.getContext().getAuthentication();
		
		Customer customer = cRepo.findByEmail(auth.getName()).get();
		
		if(customer.getOrders() == null || customer.getOrders().isEmpty()) {
			throw new OrderException("No order is made by the customer");
		}
		
		
		List<Orders> list =  customer.getOrders().stream()
												.filter(e -> e.getOrderID().equals(orderID))
												.collect(Collectors.toList());
		
		if(list.isEmpty()) {
			throw new OrderException("Invalid orderId");
		}
		
		Orders order = list.get(0);
		
		if(order.getOrderStatus().equals(OrderStatus.RETURN_IN_PROGRESS) || 
				order.getOrderStatus().equals(OrderStatus.RETURNED_AND_REFUND_IN_PROGESS) ||
				order.getOrderStatus().equals(OrderStatus.REFUNDED) || 
				order.getOrderStatus().equals(OrderStatus.CANCELLED_AND_REFUND_IN_PROGESS)) {
			throw new OrderException("Invalid action...");
		}
		
		if(order.getDeliveryDateTime().isBefore(LocalDateTime.now())) {
			
			long daysBetween = ChronoUnit.DAYS.between(order.getDeliveryDateTime(), LocalDateTime.now());
			
			if(daysBetween > 7) {
				throw new OrderException("Sorry! You can't return the product as the validity of return request facility is over");
			}
			
			List<OrderDetail> details = order.getDetails();
			
			ReturnRequestedOrders ro = new ReturnRequestedOrders();
			
			ro.setOrderID(order.getOrderID());
			ro.setRequestedON(LocalDateTime.now());
			
			ro.setFulfillON(LocalDateTime.now().plusDays(3).toLocalDate()
			.atTime(LocalTime.of(new Random().nextInt(10, 21), 
						new Random().nextInt(60), new Random().nextInt(60))));
			
			ro.setRefundON(LocalDateTime.now().plusDays(10).toLocalDate()
					.atTime(LocalTime.of(new Random().nextInt(10, 21), 
								new Random().nextInt(60), new Random().nextInt(60))));
			
			List<ReturnedOrderDetails> details2 = ro.getDetails();
			
			for(OrderDetail od : details) {
				
				ReturnedOrderDetails rod = new ReturnedOrderDetails();
				
				rod.setProductID(od.getProduct().getProductId());
				rod.setQuantity(od.getQuantity());
				
				rod.setOrder(ro);
				details2.add(rod);
				
			}
			
			rroRepo.save(ro);
			
			order.setOrderStatus(OrderStatus.RETURN_IN_PROGRESS);
			order.setReturnRequested(true);
			
			oRepo.save(order);
			
			ReturnRequestDTO dto = new ReturnRequestDTO();
			
			dto.setOrderID(orderID);
			dto.setRequestedON(ro.getRequestedON());
			dto.setFulfillON(ro.getFulfillON());
			dto.setRefundON(ro.getRefundON());
			dto.setStatus(OrderStatus.RETURN_IN_PROGRESS);
			
			return dto;
	
			
		} else {
			throw new OrderException("Product is not delivered yet, so you can't perform this action. "
					+ "Once you receive the product, please make this request again");
		}
		
		
	}
	
	
	@Override
	@Scheduled(fixedRate = 300000)
	public void updateStock() {
		
	
	
		List<ReturnRequestedOrders> orders = rroRepo.findAll();
		
	    orders.stream()
	          .forEach(e -> {
	        	  
	        	  if(!e.getFulfillON().isAfter(LocalDateTime.now()) && e.getStockUpdated() == false) {
	        		  
	        		  List<ReturnedOrderDetails> details =  e.getDetails();
	        		  
	        		  details.stream()
	        		  		 .forEach(e1 -> {
	        		  			 
	        		  			  Product pr = pRepo.findById(e1.getProductID()).get();					  
		  						  pr.setStockQuantity(pr.getStockQuantity() + e1.getQuantity());
		  						  pRepo.save(pr);
	        		  			 
	        		  		 });
	        		  
	        	  }
	        	  
	        	  e.setStockUpdated(true);
	        	  
	        	  
	          });
	    
	    
	    rroRepo.saveAll(orders);
	    
		    
		
	}
	
	
	@Override
	public List<Orders> getAllOrdersForCustomer() throws CustomerException, OrderException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		Optional<Customer> op = cRepo.findByEmail(auth.getName());
		
		if(op.isEmpty()) {
			throw new CustomerException("No customer details found in the database");
		}
		
		if(op.get().getOrders() == null || op.get().getOrders().isEmpty()) {
			throw new CustomerException("No order is found for the customer");
		}
		
		return op.get().getOrders();
	}


	@Override
	public List<Orders> getAllOrdersForAdmin() throws OrderException {
		
		List<Orders> orders = oRepo.findAll();
		
		if(orders == null || orders.isEmpty()) {
			throw new OrderException("No order found");
		}
		
		return orders;
	}


	@Override
	public Orders getOrderByOrderID(Integer orderID) throws OrderException {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		
		String role = getRole(auth.getAuthorities());
		
		if(role.equals("ROLE_CUSTOMER")) {
			
			Optional<Customer> op = cRepo.findByEmail(auth.getName());
			
			Customer customer = op.get();
			
			List<Orders> orderList =  customer.getOrders().stream()
														  .filter(e -> e.getOrderID().equals(orderID))
														  .collect(Collectors.toList());
			
			if(orderList.isEmpty()) {
				throw new OrderException("Invalid orderID");
			}
			
			return orderList.get(0);
			
		} else {
			return oRepo.findById(orderID).orElseThrow(() -> new OrderException("Invalid orderID"));
		}
		
		
	}


	@Override
	public List<Orders> getAllOrdersByCustomerID(Integer customerID)
			throws OrderException, CustomerException {
		
		Optional<Customer> op =  cRepo.findById(customerID);
		
		if(op.isEmpty()) {
			throw new CustomerException("Invalid customerID");
		}
		
		List<Orders> orders =  op.get().getOrders();
		
		if(orders == null || orders.isEmpty()) {
			throw new OrderException("No order found...");
		}
		
		return orders;
		
	}


	@Override
	public List<Orders> getAllOrdersByCustomerEmail(String email)
			throws CredentialException, OrderException, CustomerException {
		
		Optional<Customer> op =  cRepo.findByEmail(email);
		
		if(op.isEmpty()) {
			throw new CustomerException("Invalid customer email");
		}
		
		List<Orders> orders =  op.get().getOrders();
		
		if(orders == null || orders.isEmpty()) {
			throw new OrderException("No order found...");
		}
		
		return orders;
	}
	
	
	private String getRole(Collection<? extends GrantedAuthority> authorities) {
		
		return new ArrayList<>(authorities).get(0).toString();

	}


	
}
